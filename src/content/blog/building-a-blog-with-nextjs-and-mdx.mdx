---
title: "Building a Blog with Next.js and MDX"
description: "How I set up a simple, strict MDX blog system with validated categories and tags."
date: "2025-01-01"
category: "tech"
tags: ["nextjs", "typescript", "building-in-public", "web-dev"]
published: true
---

I wanted a blog that was simple to write for, version-controlled, and didn't require a CMS. Here's how I built one with Next.js and MDX.

## The Stack

- **Next.js 15** with App Router
- **gray-matter** for parsing frontmatter
- **next-mdx-remote** for rendering MDX on the server

No database. No CMS. Just `.mdx` files in a folder.

## File Structure

```
src/
  content/
    blog/
      my-post.mdx
      another-post.mdx
    config.ts        # allowed categories and tags
  lib/
    blog.ts          # parsing functions
```

Each post is a file. The slug comes from the filename. Simple.

## Frontmatter

Every post starts with YAML frontmatter:

```yaml
---
title: "Post Title"
description: "For listings and SEO"
date: "2025-01-01"
category: "tech"
tags: ["typescript", "nextjs"]
published: true
---
```

The `published` flag lets me hide drafts without deleting them.

## Strict Validation

This is the part I'm most pleased with. Categories and tags are defined in a config file:

```typescript
export const CATEGORIES = [
  'tech',
  'faith',
  'career',
  // ...
] as const

export const TAGS = [
  'typescript',
  'nextjs',
  'exploration',
  // ...
] as const
```

When parsing posts, the system validates against these lists. If I typo a tag or use an undefined category, the build fails with a helpful error:

```
Invalid tag "typsecript" in my-post.mdx.
Allowed tags: typescript, javascript, react, ...
```

This is intentional friction. It forces me to be deliberate about taxonomy instead of letting tags sprawl.

## The Parsing Code

The blog lib is straightforward. It reads files, parses frontmatter with gray-matter, validates, and returns typed data:

```typescript
export function getAllPosts(): BlogPostMeta[] {
  const files = fs.readdirSync(BLOG_DIR)
    .filter(file => /\.mdx?$/.test(file))

  return files
    .map(filename => {
      const content = fs.readFileSync(path.join(BLOG_DIR, filename), 'utf-8')
      const { data } = matter(content)

      return {
        title: data.title,
        slug: data.slug || filename.replace(/\.mdx?$/, ''),
        category: validateCategory(data.category, filename),
        tags: validateTags(data.tags, filename),
        // ...
      }
    })
    .filter(post => post.published)
    .sort((a, b) => new Date(b.date) - new Date(a.date))
}
```

## Rendering with next-mdx-remote

The individual post page uses `next-mdx-remote` to render the MDX content server-side:

```tsx
import { MDXRemote } from 'next-mdx-remote/rsc'

export default async function BlogPostPage({ params }) {
  const post = getPostBySlug(params.slug)

  return (
    <article>
      <h1>{post.title}</h1>
      <MDXRemote source={post.content} />
    </article>
  )
}
```

The `/rsc` import means it renders as a React Server Component â€” no client-side JavaScript for the MDX parsing.

## What's Next

This is a foundation. Future additions might include:

- Wiki-style `[[backlinks]]` between posts
- Syntax highlighting for code blocks
- Custom MDX components
- Category and tag filter pages

But for now, it works. I can write in my editor, commit, and deploy. That's all I need to start.

---

The full code is in [this site's repo](https://github.com/bryluke/bryanluketan-dot-com) if you want to dig deeper.
